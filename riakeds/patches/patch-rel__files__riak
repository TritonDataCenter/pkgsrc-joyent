$NetBSD$

--- rel/files/riak.orig	2012-01-13 17:55:51.000000000 +0000
+++ rel/files/riak
@@ -22,8 +22,7 @@ if [ "$RUNNER_USER" -a "x$LOGNAME" != "x
         echo "sudo doesn't appear to be installed and your EUID isn't $RUNNER_USER" 1>&2
         exit 1
     fi
-    echo "Attempting to restart script through sudo -u $RUNNER_USER"
-    exec sudo -u $RUNNER_USER -i $RUNNER_SCRIPT_DIR/$RUNNER_SCRIPT $@
+    exec sudo -u $RUNNER_USER $RUNNER_SCRIPT_DIR/$RUNNER_SCRIPT $@
 fi
 
 # Warn the user if ulimit -n is less than 1024
@@ -91,81 +90,96 @@ sed -n '/Begin SSL distribution items/,/
 # Check the first argument for instructions
 case "$1" in
     start)
-        # Make sure there is not already a node running
-        RES=`ping_node`
-        if [ "$RES" = "pong" ]; then
-            echo "Node is already running!"
-            exit 1
-        fi
-        # Sanity check the app.config file
-        RES=`$NODETOOL_LITE chkconfig $RUNNER_ETC_DIR/app.config`
-        if [ "$RES" != "ok" ]; then
-            echo "Error reading $RUNNER_ETC_DIR/app.config"
-            echo $RES
-            exit 1
-        fi
-        HEART_COMMAND="$RUNNER_SCRIPT_DIR/$SCRIPT start"
-        export HEART_COMMAND
-        mkdir -p $PIPE_DIR
-        $ERTS_PATH/run_erl -daemon $PIPE_DIR/ $RUNNER_LOG_DIR \
-            "exec $RUNNER_SCRIPT_DIR/$SCRIPT console" 2>&1
-
-        # Wait for the node to come up. We can't just ping it because
-        # distributed erlang comes up for a second before riak crashes
-        # (eg. in the case of an unwriteable disk). Once the node comes
-        # up we check for the node watcher process. If that's running
-        # then we assume things are good enough. This will at least let
-        # the user know when riak is crashing right after startup.
-        WAIT=${WAIT_FOR_ERLANG:-15}
-        while [ $WAIT -gt 0 ]; do
-            WAIT=`expr $WAIT - 1`
-            sleep 1
+        if [ "${SMF_METHOD}" == "start" ]; then
+            ULIMIT_S=$(prctl -n process.max-file-descriptor -t basic -P $$ | awk '/max-file-descriptor/ { print $3 }')
+            ULIMIT_H=$(prctl -n process.max-file-descriptor -t priv -P $$ | awk '/max-file-descriptor/ { print $3 }')
+            if [ ${ULIMIT_S} -lt ${ULIMIT_H} ]; then
+                echo "Trying to raise the file descriptor limit to maximum allowed."
+                prctl -n process.max-file-descriptor -t basic -v ${ULIMIT_H} $$ || true
+            fi
+
+            # Make sure there is not already a node running
             RES=`ping_node`
-            if [ "$?" -ne 0 ]; then
-                continue
+            if [ "$RES" = "pong" ]; then
+                echo "Node is already running!"
+                exit 1
             fi
-            NODEWATCHER=`$NODETOOL rpcterms erlang whereis "'riak_core_node_watcher'."`
-            if [ "$NODEWATCHER" != "undefined" ]; then
-                exit 0
+            # Sanity check the app.config file
+            RES=`$NODETOOL_LITE chkconfig $RUNNER_ETC_DIR/app.config`
+            if [ "$RES" != "ok" ]; then
+                echo "Error reading $RUNNER_ETC_DIR/app.config"
+                echo $RES
+                exit 1
             fi
-        done
-        echo "Riak failed to start within ${WAIT_FOR_ERLANG:-15} seconds,"
-        echo "see the output of 'riak console' for more information."
-        echo "If you want to wait longer, set the environment variable"
-        echo "WAIT_FOR_ERLANG to the number of seconds to wait."
-        exit 1
+            HEART_COMMAND="$RUNNER_SCRIPT_DIR/$SCRIPT start"
+            export HEART_COMMAND
+            mkdir -p $PIPE_DIR
+            $ERTS_PATH/run_erl -daemon $PIPE_DIR/ $RUNNER_LOG_DIR \
+                "exec $RUNNER_SCRIPT_DIR/$SCRIPT console" 2>&1
+
+            # Wait for the node to come up. We can't just ping it because
+            # distributed erlang comes up for a second before riak crashes
+            # (eg. in the case of an unwriteable disk). Once the node comes
+            # up we check for the node watcher process. If that's running
+            # then we assume things are good enough. This will at least let
+            # the user know when riak is crashing right after startup.
+            WAIT=${WAIT_FOR_ERLANG:-15}
+            while [ $WAIT -gt 0 ]; do
+                WAIT=`expr $WAIT - 1`
+                sleep 1
+                RES=`ping_node`
+                if [ "$?" -ne 0 ]; then
+                    continue
+                fi
+                NODEWATCHER=`$NODETOOL rpcterms erlang whereis "'riak_core_node_watcher'."`
+                if [ "$NODEWATCHER" != "undefined" ]; then
+                    exit 0
+                fi
+            done
+            echo "Riak failed to start within ${WAIT_FOR_ERLANG:-15} seconds,"
+            echo "see the output of 'riak console' for more information."
+            echo "If you want to wait longer, set the environment variable"
+            echo "WAIT_FOR_ERLANG to the number of seconds to wait."
+            exit 1
+        else
+            echo "use svcadm enable riak"
+        fi
         ;;
 
     stop)
-        UNAME_S=`uname -s`
-        case $UNAME_S in
-            Darwin)
-                # Make sure we explicitly set this because iTerm.app doesn't for
-                # some reason.
-                COMMAND_MODE=unix2003
-        esac
-        # Wait for the node to completely stop...
-        case $UNAME_S in
-            Linux|Darwin|FreeBSD|DragonFly|NetBSD|OpenBSD)
-                # PID COMMAND
-                PID=`ps ax -o pid= -o command=|\
-                    grep "$RUNNER_BASE_DIR/.*/[b]eam"|awk '{print $1}'`
-                ;;
-            SunOS)
-                # PID COMMAND
-                PID=`ps -ef -o pid= -o args=|\
-                    grep "$RUNNER_BASE_DIR/.*/[b]eam"|awk '{print $1}'`
-                ;;
-        esac
-        $NODETOOL stop
-        ES=$?
-        if [ "$ES" -ne 0 ]; then
-            exit $ES
+        if [ "${SMF_METHOD}" == "stop" ]; then
+            UNAME_S=`uname -s`
+            case $UNAME_S in
+                Darwin)
+                    # Make sure we explicitly set this because iTerm.app doesn't for
+                    # some reason.
+                    COMMAND_MODE=unix2003
+            esac
+            # Wait for the node to completely stop...
+            case $UNAME_S in
+                Linux|Darwin|FreeBSD|DragonFly|NetBSD|OpenBSD)
+                    # PID COMMAND
+                    PID=`ps ax -o pid= -o command=|\
+                        grep "$RUNNER_BASE_DIR/.*/[b]eam"|awk '{print $1}'`
+                    ;;
+                SunOS)
+                    # PID COMMAND
+                    PID=`ps -ef -o pid= -o args=|\
+                        grep "$RUNNER_BASE_DIR/.*/[b]eam"|awk '{print $1}'`
+                    ;;
+            esac
+            $NODETOOL stop
+            ES=$?
+            if [ "$ES" -ne 0 ]; then
+                exit $ES
+            fi
+            while `kill -0 $PID 2>/dev/null`;
+            do
+                sleep 1
+            done
+        else
+            echo "use svcadm disable riak"
         fi
-        while `kill -0 $PID 2>/dev/null`;
-        do
-            sleep 1
-        done
         ;;
 
     restart)
